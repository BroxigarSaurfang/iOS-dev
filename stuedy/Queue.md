# Queue

## Queue란 무엇인가

- Queue는 추상 데이터 구조이며 Stacks와 다소 비슷합니다. 스택과 달리 큐는 양쪽 끝에 열려 있습니다. 한쪽 끝은 항상 데이터를 삽입 (enqueue)하고 다른 쪽 끝은 데이터를 제거하는 데 사용됩니다 (dequeue). 큐는 First-In-First-Out 방법론을 따릅니다. 즉, 먼저 저장된 데이터 항목이 먼저 액세스됩니다.

![참고이미지](/Users/asurada/Downloads/queue_diagram.jpg)

- 큐는 put(insert)와 get(delete)을 이용하여 구현된다. put는 큐에 자료를 넣는 것을, get은 큐에서 자료를 꺼내는 것을 의미한다. front(head)와 rear(tail)는 데이터의 위치를 가리킨다. front는 데이터를 get할 수 있는 위치를, rear은 데이터를 put할 수 있는 위치를 의미한다. 또, 큐가 꽉 차서 더 이상 자료를 넣을 수 없는 경우(put 할 수 없는 경우)를 오버플로우(Overflow), 큐가 비어 있어 자료를 꺼낼 수 없는 경우(get 할 수 없는 경우)를 언더플로우(Underflow)라고 한다.
- 스택과 마찬가지로 큐는 배열, 링크 된 목록, 포인터 및 구조를 사용하여 구현할 수도 있습니다. 단순화를 위해 1 차원 배열을 사용하여 큐를 구현합니다.

## 종류

>선형 큐

- 막대 모양으로 된 큐이다. 크기가 제한되어 있고 빈 공간을 사용하려면 모든 자료를 꺼내거나 자료를 한 칸씩 옮겨야 한다는 단점이 있다.

 |ENQ(A)|ENQ(B)|ENQ(C)|DEQ(A)|ENQ(D)|DEQ(B)|
 |:-:|:-:|:-:|:-:|:-:|:-:|:-:|
 |||||D|D|
 |||C|C|C|C|
 ||B|B|B|B|||
 |A|A|A|||||



>환형 큐

- 선형 큐의 문제점(배열로 큐를 선언할시 큐의 삭제와 생성이 계속 일어났을때, 마지막 배열에 도달후 실제로는 데이터공간이 남아있지만 오버플로가 발생)을 보완한 것이 환형 큐이다. front가 큐의 끝에 닿으면 큐의 맨 앞으로 자료를 보내어 원형으로 연결 하는 방식이다. 
원형 큐라고도 한다.

 |ENQ(A)|ENQ(B)|ENQ(C)|ENQ(D)|DEQ(A)|ENQ(E)|
 |:-:|:-:|:-:|:-:|:-:|:-:|:-:|
 |||||D|D|D|
 ||||C|C|C|C|
 ||B|B|B|B|B|
 |A|A|A|A||E|
 
>링크드 큐(연결 리스트로 구현한 큐)

- 연결 리스트로 구현한 큐는 연결 리스트를 사용한 것으로써, 큐의 길이를 쉽게 늘릴 수 있어 오버플로우가 발생하지 않는 것이 특징이다. 필요에 따라 환형으로 만들 수도 있으며, 환형으로 만들지 않아도 삽입과 삭제가 제한되지 않아 편리하다.
 
## 기본 작업
대기열 작업에는 대기열을 초기화 또는 정의하고 이를 사용하고 메모리에서 완전히 지우는 작업이 포함될 수 있습니다.


 - enqueue () - 항목을 큐에 추가 (저장)합니다.
 - dequeue () - 대기열에서 항목을 제거 (액세스)합니다.
 - peek () - 요소를 제거하지 않고 큐 앞쪽에있는 요소를 가져옵니다.
 - isfull () - 대기열이 가득 찼는 지 확인합니다.
 - isempty () - 큐가 비어 있는지 확인합니다.

 
### peek()
이 기능을 사용하면 큐 의 맨 앞에 있는 데이터를 볼 수 있습니다.


### isfull()
큐를 구현하기 위해 단일 차원 배열을 사용하기 때문에 MAXSIZE에 도달하는 리어 포인터가 큐가 가득 찼는 지 확인합니다. 순환 링크 된 목록에 대기열을 유지하는 경우 알고리즘이 달라집니다.

## ENQ
큐는 앞면 과 뒷면의 두 데이터 포인터를 유지 합니다. 따라서 스택의 동작은 구현하기가 비교적 어렵습니다.
데이터를 대기열에 대기열에 넣기 (삽입)하려면 다음 단계를 수행해야합니다.

 1 단계 - 대기열이 가득 차 있는지 확인합니다.
 
 2 단계 - 대기열이 가득 차면 오버플로 오류를 생성하고 종료합니다.
 
 3 단계 - 대기열이 가득 차 있지 않은 경우 뒤쪽 포인터를 증가 시켜 다음 빈 공간을 가리 킵니다.
 
 4 단계 - 데이터 요소를 후면이 가리키는 큐 위치에 추가합니다.

 5 단계 - 성공을 반환합니다.
 
 ![참고이미지](/Users/asurada/Downloads/queue_enqueue_diagram.jpg)
 
때로는 예기치 않은 상황을 처리하기 위해 대기열이 초기화되었는지 여부도 확인합니다.

## DEQ
대기열에서 데이터에 액세스하는 것은 프론트 가 가리키는 데이터에 액세스하고 액세스 후 데이터를 제거하는 두 가지 작업의 프로세스입니다 . 다음 단계는 dequeue 작업 을 수행하는 데 사용 됩니다.

 1 단계 - 대기열이 비어 있는지 확인합니다.
 
 2 단계 - 대기열이 비어 있으면 언더 플로우 오류를 생성하고 종료합니다.
 
 3 단계 - 대기열이 비어 있지 않으면 전면 이 가리키는 데이터에 액세스합니다.

 4 단계 - 사용 가능한 다음 데이터 요소를 가리 키도록 앞 포인터를 증가시킵니다.

 5 단계 - 성공으로 돌아갑니다.
 
 ![참고이미지](/Users/asurada/Downloads/queue_dequeue_diagram.jpg)