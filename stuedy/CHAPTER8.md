# 구조체와 클래스

* 클래스 내부에 정의된 변수 또는 상수를 프로퍼티(Properties), 속성 변수 또는 상수
* 클래스 내부에 정의된 함수를 메소드(Method)
* 프로퍼티나 매소드를 합해서 구조체나 클래스의 멤버(Member)라고 표현

### 구조체와 클래스의 공통점

* 프로퍼티 - 변수나 상수를 사용하여 값을 저장하는 프로퍼티를 정의할 수 있다
* 메소드 - 함수를 사용하여 기능을 제공하는 메소드를 정의할 수 있다
* 서브스크립트 - 속성값에 접근할 수 있는 방법을 제공하는 서브스크립트를 정의할 수 있다
* 초기화 블록 - 객체를 원하는 초기 상태로 설정해주는 초기화 블록을 정의할 수 있다
* 확장 - 객체에 함수적 기능을 추가하는 확장(extends) 구문을 사용할 수 있다
* 프로토콜 - 특정 형식의 함수적 표준을 제공하기 위한 프로토콜을 구현할 수 있다


### 구조체와 클래스의 차이점

클래스가 구조체보다 더 기능 범위가 크기 때문에 구조체는 할수 없지만 클래스는 할 수 있는 기능들이 다음과 같이 있다

* 상속 - 클래스의 특성을 다른 클래스에게 물려줄 수 있다
* 타입 캐스팅 - 실행 시 컴파일러가 클래스 인스턴스의 타입을 미리 파악하고 검사할 수 있다
* 소멸화 구문 - 인스턴스가 소멸되기 직전에 처리해야 할 구문을 미리 등록해 놓을 수 있다
* 참조에 의한 전달 - 클래스 인스턴스가 전달될 때에는 참조 형식으로 제공되며, 이때 참조가 가능한 개수는 제약이 없다

## 구조체와 클래스의 기본 개념

* 구조체와 클래스 이름의 첫 글자는 대문자로, 나머지 글자는 소문자로 작성 (카멜(Camel)표기법)
* 2개 이상의 복합 단어는 단어별로 끊어 첫 글자는 대문자로, 나머지는 소문자로 작성
* 이미 축약된 약어는 모두 대문자로 작성 가능. ex) JSON, NS, HTTP 등
* 프로퍼티나 메소드를 선언할 때는 소문자로 시작
* 언더바로 단어를 연결하는 방식은 지양

### 메소드와 프로퍼티

```
struct Resolution {
	var width = 0
	var height = 0
	
	func desc() -> String {
		return "Resolution 구조체"
	}
}

class VideoMode {
	var interlaced = false
	var frameRate = 0.0
	var name : String?
	
	func desc() -> String {
		return "VideoMode 클래스"
	}
}
```

### 인스턴스

* 단순히 정의된 객체는 메모리 공간을 할당받은 객체가 필요
* 구조체나 클래스를 정의하여 실직적인 값을 담을수 있는 것이 인스턴스

```
인스턴스 생성구문 : 객체가 초기화 되면서 인스턴스가 생성되고, 이 값을 변수나 상수에 할당하면 원하는 곳에서 사용 가능

// Ressolution 구조체에 대한 인스턴스를 생성하고 상수 insRes에 할당
let insRes = Resolution()

// VideoMode 클래스에 대한 인스턴스를 생성하고 상수 insVMode에 할당
let insVMode = VideoMode()
```

* 함수의 이름 다음에 오면 함수 호출 연산자 역할을하고, 클래스나 구조체 이름 다음에 오면 클래스나 구조체를 초기화 하여 인스턴스를 생성하는 인스턴스 생성 연산자가 된다

* 프로퍼티에 접근하려면 반드시 인스턴스를 먼저 생성
* 프로퍼티에 접근할 때는 점 문법(Dot Syntax)을 이용하여 인스턴스의 하위 객체에 접근

```
let width = insRes.width
print("insRes 인스턴스의 width 값은 \(width)입니다")
```

* insRes.width 프로퍼티는 구조체 내에서 대입된 값으로 초기화 되며, 이후 값을 수정하지 않았으므로 출력 결과는 0
* insRes.width 대신 Resolution.width로 접근하면 해당 프로퍼티를 찾을수 없다는 오류 발생

* 객체에 정의된 프로퍼티가 서브 프로퍼티를 가지고 있는 객체라면 다음과 같이 계속 점 구문을 이용하여 단계적으로 접근

```
class videoMode {
	var interlaced = false
	var frameRate = 0.0
	var name : String?

	var res = Resolution()

	...(중략)...
	
}

// VideoMode 클래스에 대한 인스턴스를 생성하고 상수에 할당
let vMode = videoMode()

print("vMode 인스턴스의 width 값은 \(vMode.res.width)입니다")

```

* 점 구문은 프로퍼티에 값을 대입할 때에도 사용

```
vMode.name = "Sample"
vMode.res.width = 1280

print("\(vMode.name!) 인스턴스의 width 값은 \(vMode.res.width)입니다")

```

* 체인(Chain) : 점 구문을 사용하여 프로퍼티의 하위 프로퍼티까지 직접 참조할 수 있는 것과 마찬가지로, 프로퍼티의 하위 프로퍼티에 값을 할당할 때도 위와 같이 점 구문을 연속으로 연결하여 값을 할당할 수 있는 방법

* 체인 방식의 연속된 접근이 지원되지 않는다면 단계적인 할당 과정을 거쳐서 하위 프로퍼티에 접근

```
var res = vMode.res
res.width = 1280
```

#### 초기화

* 스위프트에서 옵셔널 타입으로 선언되지 않은 모든 프로퍼티는 명시적으로 초기화 해주어야 한다.
* 구조체나 클래스 이름 뒤에 빈 괄호를 붙이거나 인자값을 넣어주는 방법
* 클래스나 구조체의 모든 프로퍼티는 적어도 인스턴스가 생성되는 시점까지는 반드시 초기화되어야 한다.
* 선언과 동시에 초기값을 지정하는것이 좋지만, 그럴수 없다면 인스턴스 과정, 즉 초기화 메소드 내에서 초기값을 입력 받아야 한다.
* 명시적으로 초기화 하는 방법
	- 프로퍼티를 선언하면서 동시에 초기값을 지정하는 경우
	- 초기화 메소드 내에서 프로퍼티의 초기값을 지정하는 경우
	- 두가지 이외는 옵셔널 타입으로 선언

#### 구조체 초기화

* 구조체는 모든 프로퍼티의 값을 인자값으로 입력받아 초기화하는 기본 초기화 구문을 자동으로 제공
* 프로퍼티를 보통 멤버 변수라고 부르는 까닭에, 이 초기화 구문을 멤버와이즈 초기화 구문(Memberwise Initalizer)라고 부르기도 한다.

```
struct Resolution {
	var width = 0
	var height = 0
}

let defaultRes = Resolution(width: 1024, height: 768)
print("width:\(defaultRes.width), height:\(defaultRes.height)")
width: 1024, heigth: 768

```
* 프로퍼티의 초기 설정값은 0이었지만 각각 1024, 768로 바뀐게 아닌 초기화되었다.
* 입력한 값이 프로퍼티의 초기값으로 설정된 결과

```
Resolution() // 기본 초기화 구문. 내부적으로 프로퍼티를 초기화하지 않음. 선언과 동시에 객체의 모든 프로퍼티는 초기값이 지정되어 있어야 한다.

```

#### 클래스 초기화

* 클래스에서 제공되는 것은 빈 괄호 형태의 기본 초기화 구문
* 모든 프로퍼티가 선언과 동시에 초기화 되어 있을 때에만 사용할 수 있다.
* 만약 초기화 되지 않은 프로퍼티가 있다면 기본 초기화 구문은 사용 불가, 이 때에는 직접 초기화 구문을 정의해서 내부에서 프로퍼티를 초기화해 주어야 한다.
	- 모든 프로퍼티는 정의할 때 초기값을 지정 또는 옵셔널 타입으로 선언
	- 인스턴스를 생성할 때에는 클래스명 뒤에 ()를 붙여준다.


#### 구조체의 값 전달 방식 : 복사에 의한 전달

* 구조체는 인스턴스를 생성한 후 이를 변수나 상수에 할당하거나 함수의 인자값으로 전달할 때 값을 복사하여 전달하는 방식을 사용
* 값 타입, 또는 복사에 의한 전달 이라고 한다.
* 스위프트에서 제공하는 정수, 문자열, 배열 또는 딕셔너리 등 모두 자료형이 구조체로 구현되었기 때문에 복사를 통해 값이 전달
* 모든 구조체 인스턴스들이 상수나 변수에 할당될 때 복사된다는 뜻

```
let hd = Resolution(width: 1920, heigth: 1080)
var cinema = hd

cinema.width = 2048
print(hd.width) // = 1920 - 값이 복사되었기 때문에 변하지 않음
```

#### 클래스의 값 전달 방식 : 참조에 의한 전달

* 메모리 주소 참조에 의한 전달 방식(Reference Type)
* 참조 타입은 변수나 상수에 할당될 때, 또는 함수의 인자값으로 전달되 때 값의 복사가 이루어지지 않는 대신 현재 존재하는 인스턴스에 대한 참조가 전달(인스턴스가 저장된 메모리 주소 정보가 전달된다는 뜻)
* 클래스 타입일 경우 항상 메모리 주소를 사용하여 객체 자체를 전달

```
let video = VideoMode()
video.name = "Original Video Instance"

print("video 인스턴스의 name 값은 \(video.name!)입니다.")
// video 인스턴스의 name 값은 Original Video Instance입니다.

let dvd = video
dvd.name = "DVD Video Instance"

func changeName(v: VideoMode) {
	v.name = "Function Video Instance"
}

changeName(v: video)
print("video 인스턴스 name 값은 \(video.name!)입니다.")
// video 인스턴스의 name 값은 Function Video Instance입니다.

```

// 클래스 인스턴스에서 단순한 값 비교는 불가능, 대신 두 대상이 값은 메모리 공간을 참조하는 인스턴스인지 비교가능

```
* 동일 인스턴스인지 비교할때 : ===
* 동일 인스턴스가 아닌지 비교할때 : !===

if (video === dvd) {
	print("video와 dvd는 동일한 VideoMode 인스턴스를 참조")
} else {
	print("video와 dvd는 서로 다른 VideoMode 인스턴스를 참조")
}
// video와 dvd는 동일한 VideoMode 인스턴스를 참조

let vs = VideoMode()
let ds = VideoMode()

if (vs === ds) {
	print("vs와 ds는 동일한 VideoMode 인스턴스를 참조")
} else {
	print("vs와 ds는 서로 다른 VideoMode 인스턴스를 참조")
}
// vs와 ds는 서로 다른 VideoMode 인스턴스를 참조
- 동일한 타입의 인스턴스 이지만 같은 메모리 주소를 참조하는것은 아니다
```

구조체를 사용하는것이 좋은 예

1. 서로 연관된 몇 개의 기본 데이터 타입들을 갭슐화하여 묶는 것이 목적일 때
2. 캡슐화된 데이터에 상속이 필요하지 않을 때
3. 캡슐화된 데이터를 전달하거나 할당하는 과정에서 참조 방식 보다는 값이 복사되는 것이 합리적일 때
4. 캡슐화된 원본 데이터를 보존해야 할 때

### 프로퍼티 ( Property )

* 저장 프로퍼티
	- 입력된 값을 저장하거나 저장된 값을 제공하는 역할
	- 상수 및 변수를 사용해서 정의 가능
	- 클래스와 구조체에서는 사용이 가능하지만, 열거형에서는 사용할 수 없음

* 연산 프로퍼티
	- 특정 연산을 통해 값을 만들어 제공하는 역할
	- 변수만 사용해서 정의 가능
	- 클래스, 구조체, 열거형 모두에서 사용 가능


* 프로퍼티를 사용하려면 인스턴스가 필요
* 인스턴스를 생성한 다음 이 인스턴스를 통해서 프로퍼티를 참조하거나 값을 할당
* 인스턴스에 소속되는 프로퍼티를 인스턴스 프로퍼티라고 한다
* 예외적으로 일부 프로퍼티는 클래스와 구조체 자체에 소속되어 값을 가지기도 하는데 이런 프로퍼티들을 타입 프로퍼티라고 한다. 타입 프로퍼티는 인스턴스를 생성하지 않아도 사용 가능

```
역할에 따른 분류 [ 저장프로퍼티, 연산 프로퍼티]
소속에 따른 분류 [ 인스턴스 프로퍼티, 타입 프로퍼티]
```

#### 저장 프로퍼티

프로퍼티 선언

```
class User {
	var name: string
}

// 초기화 구문을 작성하고, 그 안에서 초기값을 할당해 주는 방법

class User {
	var name: string
	
	init() {
		self.name = ""
	}
}



// 옵셔털 타입으로 지정하는 방법

class User {
	var name: string?
	
	or
	
	var name: string!
}



// 프로퍼티에 초기값을 할당해 주는 방법
class User {
	var name: string =. "
}

```


#### 저장 프로퍼티의 분류

* var 키워드로 정의되는 변수형 저장 프로퍼티( 멤버 변수 )
* let 키워드로 정의되는 상수형 저장 프로퍼티( 멤버 상수 )
* 변수나 상수의 성격을 그대로 물려받아, 값의 수정 여부에 영향을 줌

```
구조체에서 저장 프로퍼티

// 고정 길이 범위 구조체
struct FixedLengthRange {
	var startValue: Int  // 시작값
	let length: Int. // 값의 범위
}


// 가변 길이 범위 구조체
struct FlexibleLengthRange {
	let startValue: Int  // 시작값
	var length: Int. // 값의 범위
}


// 아래 구조체 인스턴스는 정수값 0,1,2를 의미
var rangeOfFixedIntegers = FixedLengthRange(startValue: 0, length: 3)

// 아래처럼 시작값을 변경하면 객체 인스턴스는 정수값 4,5,6을 의미
rangeOfFixedIntegers.startValue = 4

// 아래 구조체 인스턴스는 정수값 0,1,2를 의미
var rangeOfFlexibleIntegers = FlexibelLengthRange(starValue:0 length: 3)

// 아래처럼 범위값을 변경하면 객체 인스턴스는 정수값 0,1,2,3,4를 의미
rangeOfFlexibleIntegers.length = 5


// 상수에 할당된 구조체 인스턴스는 변경불가
반면 클래스 인스턴스를 상수에 할당하더라도 클래스 내에서 변수로 선언한 저장 프로퍼티는 얼마든지 값을 수정 가능
구조체는 값에 의한 전달 방식으로 인스턴스가 변수나 상수에 할당되고, 클래스는 참조에 의한 전달 방식으로 인스턴스의 레퍼런스가 변수나 상수에 할당되기 때문
따라서 구조체는 저장 프로퍼티의 값이 바뀌면 상수에 할당된 인스턴스 전체가 변경되고, 클래스는 저장 프로퍼티의 값이 바뀌더라도 상수에 할당된 인스턴스의 레퍼런스는 변경되지 않는다
```

#### 지연 저장 프로퍼티 ( Stored Property )

* 클래스 인스턴스가 생성되어 모든 저장 프로퍼티가 만들어 지더라도 lazy 키워드가 붙은 프로퍼티는 선언만 될 뿐 초기화 되지 않고 계속 대기하고 있다가 프로퍼티가 호출되는 순간 초기화
* 만약 클래스나 구조체 인스턴스가 대입된다면, 프로퍼티가 호출되기 전까지는 해당 인스턴스는 초기화되지 않는다.
* 실제로 호출되는 시점에서 초기화

```
class OnCreate {
	init() {
		print("OnCreate!!")
	}
}

class LazyTest {
	var base = 0
	lazy var late = OnCreate()
	
	init() {
		print("Lazy Test")
	}
}

let lz = lazyTest()
// "Lazy Test"

lz.late
// "OnCreate!!"

두번째 호출부터는 처음 초기화된 값을 그대로 사용할 뿐 다시 초기화 되지는 않는다
```

#### 클로저를 이용한 저장 프로퍼티 초기화

* 연산이나 로직 처리를 통해 얻어진 값을 이용하여 초기화해야 하는 경우 클로저를 사용하여 필요한 로직을 실행한 다음, 반환되는 값을 이용하여 저장 프로퍼티를 초기화할 수 있다.
* 로직을 통해 값을 구한다는 점에서 연산 프로퍼티와 유사하지만 참조될 때마다 매번 값이 재평가 되는 연산 프로퍼티와 달리 최초 한번만 값이 평가된다는 차이를 가진다

```
let/var 프로퍼티명: 타입 = {
	정의 내용
	return
}()

// 정의된 클로저 구문은 클래스나 구조체의 인스턴스가 구조체의 인스턴스가 생성될 때 함께 실행되어 초기값을 반환하고, 이후로는 해당 인스턴스 내에서 재실행 되지 않는다.
저장 프로퍼티의 값 역시 몇 번을 다시 참조하더라도 재평가 되지 않는다
```

```
class PropertyInit {

	// 저장 프로퍼티 - 인스턴스 생성 시 최초 한 번만 실행
	var value01: String! = {
		print("value01 execute")
		return "value01"
	}()
	
	// 저장 프로퍼티 - 인스턴스 생성 시 최초 한 번만 실행
	let value02: String! = {
		print("value02 execute")
		return "value02"
	}()
}

let s = PropertyInit()
// value01 execute
// value02 execute
저장 프로퍼티의 값이 평가되는 시점이 인스턴스를 생성하는 인스턴스를 생성하는 시점이기 때문

s.value01
s.value02

// 실행 결과 없음
저장 프로퍼티에 정의된 클로저 구문이 더 이상 재실행되지 않기 때문
```

```
// 클로저 구문을 실행하여 결과값을 저장 프로퍼티에 대입하고 싶지만, 처음부터 클로저를 실행하는 저장 프로퍼티의 특성이 부담스러울 경우

lazy var 프로퍼티명: 타입 =. 
	정의 내용
	return 반환값
}()

lazy var value03: String! = {
	print("value03 execute")
	return "value03"
}()

let s1 = PropertyInit()

// value01 execute
// value02 execute

s1.value03

// value03 execute
```

#### 연산 프로퍼티 ( computed property)

* 실제 값을 저장햇다가 반환하지는 않고 대신 다른 프로퍼티의 값을 연산 처리하여 간접적으로 제공
* 프로퍼티의 값을 참조하기 위해 내부적으로 사용하는 구문이 get 구문
* 함수와 비슷해서 내부적으로 return 키워드를 사용하여 값을 반환하는데, 여기서 반환되는 값이 프로퍼티가 제공하는 값이된다.
* 선택적으로 set 구문을 추가가능, 이는 연산 프로퍼티에 값을 할당하거나 변경하고자 할 때 실행되는 구문














